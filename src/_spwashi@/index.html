<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>spwashi@</title>
    <script>
      function sleepFn(waitTime, loop, params = {}) {
        return new Promise((res, rej) => setTimeout(() => loop(params).then(res).catch(rej), waitTime));
      }
    </script>
    <script type="module">
      import "../css/style.css";
      import "../css/dataindex.css";
      import "../css/_spwashi@.scss";
      import {app}                   from '../js'
      import {processSpwInput}       from "../js/modes/spw/process-spw-input";
      import {mapNodes, pushNode}    from "../js/simulation/nodes/data/operate";
      import {boonConcept, boonNode} from "../js/modes/spw/commands/boon";
      import {filterNodes}           from "../js/simulation/nodes/data/set";
      import {pushLink}              from "../js/simulation/edges/data/pushLink";
      import {clearActiveNodes}      from "../js/init/hotkeys/handlers/clear-active-nodes";
      import {removeAllLinks}        from "../js/simulation/edges/data/set";

      app();

      const MAIN_LOOP_INTERVAL = 50;

      const conditionalResponses     = [
        [
          ({quantity, counter}) => counter >= (quantity * 5),
          (state) => {
            clearActiveNodes();
            window.spwashi.reinit();
            return {
              ...state,
              previousValue:   null,
              counterVariable: 0
            };
          }
        ],
        [
          ({quantity, counter}) => (counter % quantity) === 0,
          (state) => ({
            ...state,
            previousValue: null
          })
        ],
      ];
      const postConditionalResponses = [
        [
          ({quantity, counter}) => counter >= (quantity * 5),
          (state, {interval, nodeCount}) => {
            setTimeout(() => {
              filterNodes((node) => node.kind !== '__boon');
              mapNodes((node) => { node.fy = (node.fy || node.y) + 10; });
            }, (interval * nodeCount * 2 / 3))
            return state;
          }
        ],
        [
          ({quantity, counter}) => (counter % quantity) === 0,
          (state, {interval, nodeCount}) => {
            window.spwashi.boon(interval / 2, nodeCount)
                  .then(nodes => {
                    nodes.forEach(node => { node.fy += 50; });
                    window.spwashi.reinit();
                  })
            return state;
          }],
      ];

      function localTickHandler() {
        mapNodes((node) => {
          node.fy += 5;
          node.r += 5;
        });
      }

      function getLoopCallback(speed, word, {charge = 100}) {
        return async (currentState) => {
          localTickHandler(currentState);
          const presumptiveState = {
            counterVariable: currentState.counterVariable + 1,
          }

          const aggregate   = {__internalword: word};
          const potential   = derivePotential(aggregate);
          const midStep     = intermediate(currentState, presumptiveState, potential);
          const currentNode = synthesize(potential, aggregate, currentState, midStep);
          window.spwashi.reinit();

          processSpwInput([
                            `color=3`,
                            'arrange',
                            `charge=${charge}`
                          ]);

          const nextState = {
            ...currentState,
            ...presumptiveState,
            ...midStep,
            previousValue: currentNode
          };

          mainLoopHandler(speed, {charge: -charge}, nextState);

          return nextState;
        };

        function derivePotential(aggregate) {
          return aggregate.__internalword.length;
        }

        function deriveNode(potential, aggregate, currentState) {
          const heightMod         = potential;
          const identity          = aggregate.__internalword.split('')[currentState.counterVariable % potential];
          const fy                = window.spwashi.parameters.height * ((currentState.counterVariable % heightMod) / heightMod);
          const fx                = (((currentState.counterVariable % potential) / potential) * window.spwashi.parameters.width) + ((1 / (2 * potential)) * window.spwashi.parameters.width);
          const newNode           = {
            id:       currentState.counterVariable,
            identity: identity,

            fx: fx,
            fy: fy,
            y:  fy,
          };
          newNode.color           = 'var(--bg-start)';
          newNode.r               = 20;
          newNode.text            = {
            fontSize: 50,
            fy:       50,
            color:    'white'
          }
          newNode.collisionRadius = 100;
          return newNode;
        }

        function intermediate(currentState, presumptiveState, potential) {
          let intermediateState = {...currentState, ...presumptiveState};
          const stepParameters  = {
            quantity: potential,
            counter:  currentState.counterVariable,
          };
          conditionalResponses.forEach(([condition, callback]) => {
            if (condition(stepParameters)) {
              intermediateState = {
                ...intermediateState,
                ...callback(intermediateState)
              }
            }
          });
          return intermediateState;
        }

        function synthesize(potential, aggregate, currentState, intermediateState) {
          // nodes
          const currentNode = deriveNode(potential, aggregate, currentState);
          pushNode(currentNode);

          // links
          const previousNode = intermediateState.previousValue;
          if (previousNode) {
            pushLink(window.spwashi.links, {
              source:   currentNode,
              target:   previousNode,
              strength: .3
            });
          }
          return currentNode;
        }
      }

      function getPostLoopCallback(interval = 100, nodeCount = 13) {
        return (currentState) => {
          const checkParams = {
            quantity: nodeCount,
            counter:  currentState.counterVariable,
          };

          let intermediateState = {...currentState};
          postConditionalResponses.forEach(([condition, callback]) => {
            if (condition(checkParams)) {
              const iterationState = callback(currentState, {interval, nodeCount});
              intermediateState    = {
                ...intermediateState,
                ...iterationState
              }
            }
          });

          return {...intermediateState};
        };
      }

      async function mainLoopHandler(interval, motion, stateVariables) {
        const locale    = 'en-US';
        const dayName   = (new Date()).toLocaleDateString(locale, {weekday: 'long'}).toLowerCase();
        const nodeCount = 7;

        const loop      = getLoopCallback(interval, dayName, motion);
        const nextState = await sleepFn(interval, loop, stateVariables)

        const postLoopCallback = getPostLoopCallback(interval, nodeCount);
        return postLoopCallback(nextState);
      }

      boonConcept['@node'] = (index, batchSize) => {
        const currentDayIndex = (new Date()).getDay();
        return {
          ...boonNode(index, batchSize),
          text:      {
            fontSize: 50,
            fy:       50,
            color:    'rgba(255, 255, 255, .2)'
          },
          color:     index === currentDayIndex ? 'turquoise' : 'rgba(255, 255, 255, .1)',
          callbacks: {
            ondrag: (e, node) => {
              const width  = window.spwashi.parameters.width;
              const height = window.spwashi.parameters.height;
              const r      = 255 * (node.x / width);
              const y      = 255 * (node.y / height);
              const b      = 255 * (node.x / width);

              node.color = `rgb(${r}, ${y}, ${b})`;
            }
          }
          // r: 10
        };
      }

      setTimeout(() => {
        processSpwInput(['box=0',]);
        const stateVariables = {
          previousValue:   null,
          counterVariable: 0
        }
        mainLoopHandler(MAIN_LOOP_INTERVAL, {charge: 1000}, stateVariables);
      }, 300);
    </script>
    <style>
        :root {
            --bg-start: #008080;
            --bg-end: #67bdb0;
        }

        @keyframes html-background {
            from { background-color: var(--bg-start); }
            to { background-color: var(--bg-end); }
        }

        html {
            animation-name: html-background;
            animation-duration: 2s;
            animation-fill-mode: forwards;
        }

        body {
            animation-name: html-background;
            animation-duration: 2s;
            animation-fill-mode: forwards;
            --bg-end: #008080;
            --bg-start: rgba(239, 239, 239, .3);
        }
    </style>
</head>
<body>
    <h1>_spwashi@</h1>
    <a id="title-md5" tabindex="-1"></a>
    <svg id="simulation">
        <g class="simulation-content">
            <g class="rects"></g>
            <g class="edges"></g>
            <g class="nodes"></g>
        </g>
    </svg>
    <button class="enable-sounds">enable sounds</button>
    <button class="disable-sounds">disable sounds</button>
</body>
</html>